package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"time"

	"github.com/eternisai/enchanted-proxy/graph/model"
	"github.com/eternisai/enchanted-proxy/pkg/telegram"
	"github.com/google/uuid"
	nats "github.com/nats-io/nats.go"
)

// SendTelegramMessage is the resolver for the sendTelegramMessage field.
func (r *mutationResolver) SendTelegramMessage(ctx context.Context, chatUUID string, text string) (bool, error) {
	r.Logger.Info("SendTelegramMessage mutation called", "chatUUID", chatUUID, "text", text)

	// Validate UUID format
	if _, err := uuid.Parse(chatUUID); err != nil {
		return false, fmt.Errorf("invalid chatUUID format: %w", err)
	}

	// Look up the Telegram chat ID from the chatUUID
	chatID, exists := r.TelegramService.GetChatIDByUUID(chatUUID)
	if !exists {
		return false, fmt.Errorf("no chat found for UUID %s", chatUUID)
	}

	// Send the message using the Telegram service
	err := r.TelegramService.SendMessage(ctx, chatID, text)
	if err != nil {
		return false, fmt.Errorf("failed to send message: %w", err)
	}

	r.Logger.Info("Message sent successfully via Telegram", "chatUUID", chatUUID, "chatID", chatID, "message", text)
	return true, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "GraphQL server is healthy", nil
}

// TelegramMessageAdded is the resolver for the telegramMessageAdded field.
func (r *subscriptionResolver) TelegramMessageAdded(ctx context.Context, chatUUID string) (<-chan *model.Message, error) {
	r.Logger.Info("TelegramMessageAdded subscription started", "chatUUID", chatUUID)

	// Validate UUID format
	if _, err := uuid.Parse(chatUUID); err != nil {
		return nil, fmt.Errorf("invalid chatUUID format: %w", err)
	}

	// Create a unique subscription ID
	subscriptionID := uuid.New().String()

	// Create a channel for this subscription
	messageChan := make(chan *model.Message, 10) // Buffered channel

	// Store the subscription
	r.subscriptionsMu.Lock()
	if r.subscriptions == nil {
		r.subscriptions = make(map[string]map[string]chan *model.Message)
	}
	if r.subscriptions[chatUUID] == nil {
		r.subscriptions[chatUUID] = make(map[string]chan *model.Message)
	}
	r.subscriptions[chatUUID][subscriptionID] = messageChan
	r.subscriptionsMu.Unlock()

	// Set up NATS subscription if available, otherwise use direct callbacks
	var natsSub *nats.Subscription
	var callbackID string
	var err error
	if r.NatsClient != nil {
		// Subscribe to NATS messages for this chat UUID
		subject := fmt.Sprintf("telegram.chat.%s", chatUUID)
		natsSub, err = r.NatsClient.Subscribe(subject, func(msg *nats.Msg) {
			r.Logger.Info("Received NATS message", "subject", subject, "data", string(msg.Data))

			// Parse the message
			var telegramMsg telegram.Message
			if err := json.Unmarshal(msg.Data, &telegramMsg); err != nil {
				r.Logger.Error("Failed to unmarshal NATS message", "error", err)
				return
			}

			// Convert to GraphQL model
			graphqlMsg := &model.Message{
				ID:        strconv.Itoa(telegramMsg.MessageID),
				Text:      telegramMsg.Text,
				ChatID:    telegramMsg.Chat.ID,
				ChatUUID:  chatUUID,
				Date:      telegramMsg.Date,
				MessageID: telegramMsg.MessageID,
				Role:      "user", // Messages from Telegram are always from users
				CreatedAt: time.Unix(int64(telegramMsg.Date), 0).Format(time.RFC3339),
				From: &model.User{
					ID:        telegramMsg.From.ID,
					FirstName: telegramMsg.From.FirstName,
					LastName:  &telegramMsg.From.LastName,
					Username:  &telegramMsg.From.Username,
				},
			}

			// Send to all subscribers for this chatUUID
			r.subscriptionsMu.RLock()
			if subscribers, exists := r.subscriptions[chatUUID]; exists {
				for _, subChan := range subscribers {
					select {
					case subChan <- graphqlMsg:
						r.Logger.Debug("Message sent to subscriber", "chatUUID", chatUUID)
					default:
						r.Logger.Warn("Subscriber channel full, dropping message", "chatUUID", chatUUID)
					}
				}
			}
			r.subscriptionsMu.RUnlock()
		})

		if err != nil {
			r.Logger.Error("Failed to subscribe to NATS", "error", err, "subject", subject)
		} else {
			r.Logger.Info("Subscribed to NATS", "subject", subject)
		}
	} else if r.TelegramService != nil {
		// NATS not available, use direct callbacks
		r.Logger.Info("NATS not available, registering direct callback", "chatUUID", chatUUID)
		callbackID = r.TelegramService.RegisterMessageCallback(chatUUID, func(telegramMsg telegram.Message, uuid string) {
			r.Logger.Info("Received message via direct callback", "chatUUID", uuid, "messageID", telegramMsg.MessageID)

			// Convert to GraphQL model
			graphqlMsg := &model.Message{
				ID:        strconv.Itoa(telegramMsg.MessageID),
				Text:      telegramMsg.Text,
				ChatID:    telegramMsg.Chat.ID,
				ChatUUID:  uuid,
				Date:      telegramMsg.Date,
				MessageID: telegramMsg.MessageID,
				Role:      "user", // Messages from Telegram are always from users
				CreatedAt: time.Unix(int64(telegramMsg.Date), 0).Format(time.RFC3339),
				From: &model.User{
					ID:        telegramMsg.From.ID,
					FirstName: telegramMsg.From.FirstName,
					LastName:  &telegramMsg.From.LastName,
					Username:  &telegramMsg.From.Username,
				},
			}

			// Send to all subscribers for this chatUUID
			r.subscriptionsMu.RLock()
			if subscribers, exists := r.subscriptions[uuid]; exists {
				for _, subChan := range subscribers {
					select {
					case subChan <- graphqlMsg:
						r.Logger.Debug("Message sent to subscriber via callback", "chatUUID", uuid)
					default:
						r.Logger.Warn("Subscriber channel full, dropping message via callback", "chatUUID", uuid)
					}
				}
			}
			r.subscriptionsMu.RUnlock()
		})
	}

	// Clean up when context is cancelled
	go func() {
		<-ctx.Done()
		r.Logger.Info("Subscription context cancelled", "chatUUID", chatUUID, "subscriptionID", subscriptionID)

		// Unsubscribe from NATS or unregister callback
		if natsSub != nil {
			natsSub.Unsubscribe()
		}
		if callbackID != "" && r.TelegramService != nil {
			r.TelegramService.UnregisterMessageCallback(chatUUID, callbackID)
		}

		// Remove from subscriptions map
		r.subscriptionsMu.Lock()
		if subscribers, exists := r.subscriptions[chatUUID]; exists {
			delete(subscribers, subscriptionID)
			if len(subscribers) == 0 {
				delete(r.subscriptions, chatUUID)
			}
		}
		r.subscriptionsMu.Unlock()

		// Close the channel
		close(messageChan)
	}()

	return messageChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type (
	mutationResolver     struct{ *Resolver }
	queryResolver        struct{ *Resolver }
	subscriptionResolver struct{ *Resolver }
)
