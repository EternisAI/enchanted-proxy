// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitecodes.sql

package pgdb

import (
	"context"
	"time"
)

const atomicUseInviteCode = `-- name: AtomicUseInviteCode :exec
UPDATE invite_codes 
SET is_used = true, redeemed_by = $2, redeemed_at = $3, updated_at = NOW() 
WHERE code_hash = $1 
  AND deleted_at IS NULL 
  AND is_active = true 
  AND is_used = false 
  AND (expires_at IS NULL OR expires_at > NOW())
  AND (bound_email IS NULL OR bound_email = $4)
`

type AtomicUseInviteCodeParams struct {
	CodeHash   string     `json:"codeHash"`
	RedeemedBy *string    `json:"redeemedBy"`
	RedeemedAt *time.Time `json:"redeemedAt"`
	BoundEmail *string    `json:"boundEmail"`
}

func (q *Queries) AtomicUseInviteCode(ctx context.Context, arg AtomicUseInviteCodeParams) error {
	_, err := q.db.ExecContext(ctx, atomicUseInviteCode,
		arg.CodeHash,
		arg.RedeemedBy,
		arg.RedeemedAt,
		arg.BoundEmail,
	)
	return err
}

const countInviteCodesByRedeemedBy = `-- name: CountInviteCodesByRedeemedBy :one
SELECT COUNT(*) FROM invite_codes 
WHERE redeemed_by = $1 AND deleted_at IS NULL
`

func (q *Queries) CountInviteCodesByRedeemedBy(ctx context.Context, redeemedBy *string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countInviteCodesByRedeemedBy, redeemedBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInviteCode = `-- name: CreateInviteCode :one
INSERT INTO invite_codes (code, code_hash, bound_email, created_by, is_used, redeemed_by, redeemed_at, expires_at, is_active, created_at, updated_at) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW()) 
RETURNING id, code, code_hash, bound_email, created_by, is_used, redeemed_by, redeemed_at, expires_at, is_active, created_at, updated_at, deleted_at
`

type CreateInviteCodeParams struct {
	Code       string     `json:"code"`
	CodeHash   string     `json:"codeHash"`
	BoundEmail *string    `json:"boundEmail"`
	CreatedBy  int64      `json:"createdBy"`
	IsUsed     bool       `json:"isUsed"`
	RedeemedBy *string    `json:"redeemedBy"`
	RedeemedAt *time.Time `json:"redeemedAt"`
	ExpiresAt  *time.Time `json:"expiresAt"`
	IsActive   bool       `json:"isActive"`
}

func (q *Queries) CreateInviteCode(ctx context.Context, arg CreateInviteCodeParams) (InviteCode, error) {
	row := q.db.QueryRowContext(ctx, createInviteCode,
		arg.Code,
		arg.CodeHash,
		arg.BoundEmail,
		arg.CreatedBy,
		arg.IsUsed,
		arg.RedeemedBy,
		arg.RedeemedAt,
		arg.ExpiresAt,
		arg.IsActive,
	)
	var i InviteCode
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CodeHash,
		&i.BoundEmail,
		&i.CreatedBy,
		&i.IsUsed,
		&i.RedeemedBy,
		&i.RedeemedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllInviteCodes = `-- name: GetAllInviteCodes :many
SELECT id, code, code_hash, bound_email, created_by, is_used, redeemed_by, redeemed_at, expires_at, is_active, created_at, updated_at, deleted_at FROM invite_codes 
WHERE deleted_at IS NULL 
ORDER BY created_at DESC
`

func (q *Queries) GetAllInviteCodes(ctx context.Context) ([]InviteCode, error) {
	rows, err := q.db.QueryContext(ctx, getAllInviteCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InviteCode{}
	for rows.Next() {
		var i InviteCode
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.CodeHash,
			&i.BoundEmail,
			&i.CreatedBy,
			&i.IsUsed,
			&i.RedeemedBy,
			&i.RedeemedAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInviteCodeByCodeHash = `-- name: GetInviteCodeByCodeHash :one
SELECT id, code, code_hash, bound_email, created_by, is_used, redeemed_by, redeemed_at, expires_at, is_active, created_at, updated_at, deleted_at FROM invite_codes 
WHERE code_hash = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInviteCodeByCodeHash(ctx context.Context, codeHash string) (InviteCode, error) {
	row := q.db.QueryRowContext(ctx, getInviteCodeByCodeHash, codeHash)
	var i InviteCode
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CodeHash,
		&i.BoundEmail,
		&i.CreatedBy,
		&i.IsUsed,
		&i.RedeemedBy,
		&i.RedeemedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInviteCodeByID = `-- name: GetInviteCodeByID :one
SELECT id, code, code_hash, bound_email, created_by, is_used, redeemed_by, redeemed_at, expires_at, is_active, created_at, updated_at, deleted_at FROM invite_codes 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInviteCodeByID(ctx context.Context, id int64) (InviteCode, error) {
	row := q.db.QueryRowContext(ctx, getInviteCodeByID, id)
	var i InviteCode
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CodeHash,
		&i.BoundEmail,
		&i.CreatedBy,
		&i.IsUsed,
		&i.RedeemedBy,
		&i.RedeemedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const resetInviteCode = `-- name: ResetInviteCode :exec
UPDATE invite_codes 
SET is_used = false, redeemed_by = NULL, redeemed_at = NULL, updated_at = NOW() 
WHERE code_hash = $1 AND deleted_at IS NULL
`

func (q *Queries) ResetInviteCode(ctx context.Context, codeHash string) error {
	_, err := q.db.ExecContext(ctx, resetInviteCode, codeHash)
	return err
}

const softDeleteInviteCode = `-- name: SoftDeleteInviteCode :exec
UPDATE invite_codes 
SET deleted_at = NOW(), updated_at = NOW() 
WHERE id = $1
`

func (q *Queries) SoftDeleteInviteCode(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteInviteCode, id)
	return err
}

const updateInviteCodeActive = `-- name: UpdateInviteCodeActive :exec
UPDATE invite_codes 
SET is_active = $2, updated_at = NOW() 
WHERE id = $1
`

type UpdateInviteCodeActiveParams struct {
	ID       int64 `json:"id"`
	IsActive bool  `json:"isActive"`
}

func (q *Queries) UpdateInviteCodeActive(ctx context.Context, arg UpdateInviteCodeActiveParams) error {
	_, err := q.db.ExecContext(ctx, updateInviteCodeActive, arg.ID, arg.IsActive)
	return err
}

const updateInviteCodeUsage = `-- name: UpdateInviteCodeUsage :exec
UPDATE invite_codes 
SET is_used = $2, redeemed_by = $3, redeemed_at = $4, updated_at = NOW() 
WHERE id = $1
`

type UpdateInviteCodeUsageParams struct {
	ID         int64      `json:"id"`
	IsUsed     bool       `json:"isUsed"`
	RedeemedBy *string    `json:"redeemedBy"`
	RedeemedAt *time.Time `json:"redeemedAt"`
}

func (q *Queries) UpdateInviteCodeUsage(ctx context.Context, arg UpdateInviteCodeUsageParams) error {
	_, err := q.db.ExecContext(ctx, updateInviteCodeUsage,
		arg.ID,
		arg.IsUsed,
		arg.RedeemedBy,
		arg.RedeemedAt,
	)
	return err
}
